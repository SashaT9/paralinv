\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=1.5cm, top=2cm, includehead]{geometry}
\usepackage{titlesec}
\usepackage{array}
\usepackage{makecell}
\usepackage{booktabs}
\usepackage{fancyhdr}

\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0.4pt}
\lhead{\small\textbf{Parallel Merge Sort}}
\rhead{\small Oleksandr Tymkovych}

\titlespacing*{\section}{0pt}{6pt plus 2pt minus 2pt}{2pt plus 2pt minus 2pt}
\titleformat{\section}{\large\bfseries}{\thesection.}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection.}{1em}{}

\renewcommand{\arraystretch}{1.1}

\begin{document}

\section*{Problem}
The problem name is ``Kapral'' from the MP course.
It is equivalent to counting the number of inversions in the array.
During the course, it was required to do this using \textsc{MergeSort}.

\section*{Tests}
Each test is a uniformly random permutation with the length $n
\in
\{10^4, 2\cdot 10^5, 2\cdot 10^6,
5\cdot 10^7\}$.

\section*{Standard Merge Sort}
I implemented standard \textsc{MergeSort} in
\texttt{solutions/ms.cpp} without any optimizations.
I tried running $\texttt{InsertSort}$
if the length of the part to sort is small but the improvements were
insignificant.
Also, this solution is used to check correctness of other solutions.

\section*{Parallel Recursive Calls}
The obvious idea how to parallelize \textsc{MergeSort} is to process
the recursion calls on left and right parts on different threads.
The problem is that we then need $\mathcal{O}(n)$ threads to do this.
I fix it with adding an atomic counter to track the number of
currently active threads. Implementation is in \texttt{solutions/msthsrec.cpp}.

\section*{Parallel Merge Function}
We want to split the merge function between $t$ workers.
Suppose the instance where we have two sorted parts of sizes $m$ and
we want to merge them.
Let us split the left part into $t$ blocks, each of length $m/t$.
We also want somehow to split the right part into $t$ blocks so that
we can merge $t$ pairs of blocks in parallel.
But we cannot just choose them the same way as the left part, it can
lead to unsorted total merge.
Consider the $i$-th block from the left part. Let find $j$ as the
first greater element than the maximal element from the $i$-th block.
Then all element before $j$ that are not in any block can be matched
with the $i$-th block. In such way we have the order defined between
pair of blocks what makes it possible to merge them between one another.
Check out \texttt{solutions/msthsmer.cpp} for the implementation details.

Now about the complexity of this merge. To define these blocks we
need $\mathcal{O}(t\log m)$ time using binary search and then we can
perform $t$ merges of
parts of lengths $m/t$ in parallel. The thing is that for
small-length arrays it is just better to run standard merge on one thread.
Note, that in general case this approach does not work that nice.
The blocks from the right part could have not similar lengths which
can lead that all workes except one just do nothing.
However, because the tests are random permutations, those block
lengths should be uniformy distributed in theory.

Another interesting thing that happens is that at the very end we
want to move data from the buffer to the array.
We do not want to do it in linear time, because then all previous
observations are unnecessary.
I tried to parallelize this copy, however then I found
\texttt{std::copy} which actually works on single thread but with
some vector instructions under the hood and gives me better results.

\section*{Parallel Recursive Calls \& Merge Function}
Having two different approaches, I decided to combine them.
This time I implemented using OpenMP. There exists such thing like
$\texttt{omp task}$ which makes the implementation very easy.
Also, the $\texttt{omp parallel for}$ turned out to be even faster
than that $\texttt{std::copy}$ from previous solution.

\section*{Results}

I tested the approaches on my laptop and on student. In both cases
the best solution is the one with OpenMP and it is two times faster
then usual \textsc{MergeSort}.
\begin{table}[htbp]
  \centering
  \small
  \caption{Running on 16 threads CPU: AMD Ryzen 7 PRO 8840U}
  \begin{tabular}{l l l l l}
    \toprule
    \textbf{Solution} & \textbf{$n=10^4$} & \textbf{$n=2\cdot 10^5$} &
    \textbf{$n=2\cdot 10^6$} & \textbf{$n=5\cdot 10^7$} \\
    \midrule

    Usual &
    \makecell[l]{avg: 0.00 \\ mx: 0.00} &
    \makecell[l]{avg: 0.02 \\ mx: 0.03} &
    \makecell[l]{avg: 0.23 \\ mx: 0.23} &
    \makecell[l]{avg: 6.27 \\ mx: 6.32} \\
    \midrule

    Parallel Merge &
    \makecell[l]{avg: 0.00 \\ mx: 0.00} &
    \makecell[l]{avg: 0.02 \\ mx: 0.03} &
    \makecell[l]{avg: 0.21 \\ mx: 0.22} &
    \makecell[l]{avg: 5.50 \\ mx: 5.56} \\
    \midrule

    \makecell[l]{Parallel Recursive \\ Calls} &
    \makecell[l]{avg: 0.01 \\ mx: 0.01} &
    \makecell[l]{avg: 0.03 \\ mx: 0.04} &
    \makecell[l]{avg: 0.23 \\ mx: 0.30} &
    \makecell[l]{avg: 4.49 \\ mx: 4.98} \\
    \midrule

    \makecell[l]{Parallel Merge \& \\ Recursive Calls} &
    \makecell[l]{avg: 0.01 \\ mx: 0.02} &
    \makecell[l]{avg: 0.02 \\ mx: 0.03} &
    \makecell[l]{avg: 0.11 \\ mx: 0.13} &
    \makecell[l]{avg: 2.58 \\ mx: 2.62} \\
    \bottomrule
  \end{tabular}
\end{table}

\begin{table}[htbp]
  \centering
  \small
  \caption{Running on 144 threads CPU: Intel(R) Xeon(R) Gold 6154}
  % \vspace{-5pt}
  \begin{tabular}{l l l l l}
    \toprule
    \textbf{Solution} & \textbf{$n=10^4$} & \textbf{$n=2\cdot 10^5$} &
    \textbf{$n=2\cdot 10^6$} & \textbf{$n=5\cdot 10^7$} \\
    \midrule

    Usual &
    \makecell[l]{avg: 0.01 \\ mx: 0.01} &
    \makecell[l]{avg: 0.05 \\ mx: 0.05} &
    \makecell[l]{avg: 0.38 \\ mx: 0.39} &
    \makecell[l]{avg: 10.86 \\ mx: 11.47} \\
    \midrule

    Parallel Merge &
    \makecell[l]{avg: 0.01 \\ mx: 0.01} &
    \makecell[l]{avg: 0.05 \\ mx: 0.06} &
    \makecell[l]{avg: 0.52 \\ mx: 0.55} &
    \makecell[l]{avg: 14.15 \\ mx: 14.38} \\
    \midrule

    \makecell[l]{Parallel Recursive \\ Calls} &
    \makecell[l]{avg: 0.07 \\ mx: 0.10} &
    \makecell[l]{avg: 0.60 \\ mx: 0.92} &
    \makecell[l]{avg: 3.91 \\ mx: 6.20} &
    \makecell[l]{avg: 46.45 \\ mx: 70.29} \\
    \midrule

    \makecell[l]{Parallel Merge \& \\ Recursive Calls} &
    \makecell[l]{avg: 0.11 \\ mx: 0.14} &
    \makecell[l]{avg: 0.16 \\ mx: 0.27} &
    \makecell[l]{avg: 0.38 \\ mx: 0.43} &
    \makecell[l]{avg: 4.89 \\ mx: 5.16} \\
    \bottomrule
  \end{tabular}
\end{table}

\section*{How to Run}
All the solutions are in \texttt{src/solutions}. They can be compiled
using the \texttt{Makefile} running $\texttt{make}$ at the source
directory and the binaries
are put into $\texttt{src/bin}$ directory. The solutions are compiled
with flags $\texttt{-std=c++11 -Wall
-march=native -O3}$ plus \texttt{-fopenmp} where needed.

Then there is a bash script \texttt{testgen.sh} that generates the
tests and puts them into \texttt{src/tests} directory. Running it can
take some time.

At last, there is a python script \texttt{bench.py} for testing the solutions.
Note, the scipt uses \texttt{tqdm} module to track the progress. You
need to have it installed.
\end{document}
